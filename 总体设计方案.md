è¿™æ˜¯ä¸€ä»½ä¸ºæ‚¨é‡èº«å®šåˆ¶çš„ **ACE (Agentic Context Engineering) Node.js SDK è®¾è®¡æ–¹æ¡ˆ**ã€‚

è¿™ä»½æ–¹æ¡ˆå°†å›´ç»•æ‚¨çš„æ ¸å¿ƒæŠ€æœ¯æ ˆï¼ˆNode.js, ChromaDB, DuckDB, PouchDB/RxDBï¼‰æ„å»ºï¼Œé‡ç‚¹åœ¨äº**æ¨¡å—åŒ–ï¼ˆModularityï¼‰å’Œæ¥å£æŠ½è±¡ï¼ˆAbstractionï¼‰**ï¼Œç¡®ä¿æ ¸å¿ƒé€»è¾‘å°è£…åœ¨ SDK ä¸­ï¼Œè€Œå…·ä½“çš„æ•°æ®åº“å®ç°å¯ä»¥çµæ´»æ³¨å…¥ã€‚

-----

# é¡¹ç›®åç§°ï¼š`ace-engine-core` è®¾è®¡æ–¹æ¡ˆ

## ä¸€ã€ è®¾è®¡ç›®æ ‡

1.  **å°è£…æ€§ï¼š** å°† ACE çš„ Generatorã€Reflectorã€Curator ä¸‰å±‚é€»è¾‘å°è£…ä¸ºé»‘ç›’ã€‚
2.  **æ’ä»¶åŒ–ï¼š** å­˜å‚¨å±‚ï¼ˆVector, Logs, Trajectoryï¼‰é€šè¿‡æ¥å£ï¼ˆInterfaceï¼‰æ³¨å…¥ï¼Œä¸ç¡¬ç¼–ç å…·ä½“æ•°æ®åº“é©±åŠ¨ã€‚
3.  **å¼‚æ­¥äº‹ä»¶é©±åŠ¨ï¼š** åˆ©ç”¨ Node.js ç‰¹æ€§ï¼Œå®ç°â€œä¸»ä»»åŠ¡åŒæ­¥è¿”å›ï¼Œè¿›åŒ–ä»»åŠ¡åå°è¿è¡Œâ€ã€‚

-----

## äºŒã€ ç³»ç»Ÿæ¶æ„å›¾

```mermaid
graph TD
    %% 1. å®¿ä¸»å±‚
    subgraph HOST["Host Application"]
        API["API / Controller (API/æ§åˆ¶å™¨)"]
        DB["DB Adapters<br/>Chroma / Duck / RxDB (æ•°æ®åº“é€‚é…å™¨)"]
    end

    %% 2. SDK å±‚
    subgraph SDK["ace-engine-core"]
        ORC["ACE Orchestrator (ACE æ€»è°ƒåº¦å™¨)"]
        BUS["Event Emitter (äº‹ä»¶æ€»çº¿)"]

        subgraph COMP["Components (ç»„ä»¶å±‚)"]
            G["Generator (ç”Ÿæˆå™¨/æ‰§è¡Œå±‚)"]
            R["Reflector (åå°„å™¨/åæ€å±‚)"]
            C["Curator (ç­–å±•å™¨/ç­–å±•å±‚)"]
        end

        subgraph MEM["Memory Interfaces (å†…å­˜æ¥å£)"]
            IV["IVectorStore (å‘é‡å­˜å‚¨æ¥å£)"]
            IT["ITrajectoryStore (è½¨è¿¹å­˜å‚¨æ¥å£)"]
            IA["IAnalyticsStore (åˆ†æå­˜å‚¨æ¥å£)"]
        end
    end

    %% 3. è°ƒç”¨æµ
    API -->|"run(task) (è¿è¡Œä»»åŠ¡)"| ORC
    ORC --> G
    G -->|"Result (è¿”å›ç»“æœ)"| API
    G -.->|"Async Event (å¼‚æ­¥äº‹ä»¶)"| R
    R --> C
    C -->|"Update (æ›´æ–°)"| IV

    %% 4. å®ç°å…³ç³»
    DB -.->|"Implements (å®ç°)"| IV
    DB -.->|"Implements (å®ç°)"| IT
    DB -.->|"Implements (å®ç°)"| IA
```

-----

## ä¸‰ã€ æ ¸å¿ƒæ•°æ®ç»“æ„ (TypeScript Interfaces)

åœ¨ SDK çš„ `src/types.ts` ä¸­å®šä¹‰æ ¸å¿ƒæ•°æ®æ ‡å‡†ã€‚

```typescript
// 1. æˆ˜æœ¯æ‰‹å†Œä¸­çš„å•æ¡è§„åˆ™ (The Atom of Memory)
export interface Rule {
  id: string;           // UUID
  content: string;      // è§„åˆ™æ–‡æœ¬
  embedding?: number[]; // å‘é‡æ•°æ® (å¯é€‰ï¼Œç”± DB å¤„ç†)
  metadata: {
    created_at: number;
    last_used: number;
    success_count: number; // æˆåŠŸæ¬¡æ•°
    failure_count: number; // å¤±è´¥æ¬¡æ•°
    source_task_id?: string; // æ¥æºä»»åŠ¡ ID
  };
}

// 2. å¢é‡æ›´æ–°åŒ… (The Git Commit)
export interface Delta {
  type: 'ADD' | 'UPDATE' | 'DELETE';
  rule_id?: string;
  content?: string;      // å¦‚æœæ˜¯ ADD/UPDATE
  reasoning: string;     // Reflector çš„åŸå§‹åæ€æ–‡æœ¬
}

// 3. å®Œæ•´è½¨è¿¹ (The Raw Experience)
export interface Trajectory {
  task_id: string;
  user_input: string;
  steps: Array<{
    thought: string;
    action: string;
    output: string;
  }>;
  final_result: string;
  environment_feedback: string; // æŠ¥é”™ä¿¡æ¯æˆ–ç”¨æˆ·åé¦ˆ
  timestamp: number;
}
```

-----

## å››ã€ å­˜å‚¨é€‚é…å™¨æ¥å£ (Adapter Pattern)

è¿™æ˜¯ SDK æœ€å…³é”®çš„éƒ¨åˆ†ã€‚SDK åªè°ƒç”¨è¿™äº›æ¥å£ï¼Œ**ä¸åŒ…å« `chromadb` æˆ– `duckdb` çš„ npm åŒ…**ã€‚

```typescript
// src/interfaces/store.ts

// å‘é‡å­˜å‚¨æ¥å£ (å¯¹åº” ChromaDB)
export interface IVectorStore {
  search(query: string, limit: number): Promise<Rule[]>;
  add(rules: Rule[]): Promise<void>;
  updateMetadata(id: string, metadata: Partial<Rule['metadata']>): Promise<void>;
  delete(ids: string[]): Promise<void>;
}

// è½¨è¿¹å­˜å‚¨æ¥å£ (å¯¹åº” RxDB / PouchDB)
export interface ITrajectoryStore {
  saveTrajectory(traj: Trajectory): Promise<void>;
  getTrajectory(id: string): Promise<Trajectory | null>;
}

// åˆ†æå­˜å‚¨æ¥å£ (å¯¹åº” DuckDB)
export interface IAnalyticsStore {
  logEvent(event: { type: string; payload: any; timestamp: number }): Promise<void>;
  // DuckDB çš„å¤æ‚æŸ¥è¯¢é€šå¸¸åœ¨ Host App åšï¼ŒSDK è´Ÿè´£å†™å…¥æ—¥å¿—æµ
}
```

-----

## äº”ã€ SDK æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1\. ä¸»å…¥å£ `AceAgent`

```typescript
import { EventEmitter } from 'events';

export class AceAgent extends EventEmitter {
  private generator: Generator;
  private reflector: Reflector;
  private curator: Curator;

  constructor(config: {
    llm: BaseLLM;             // ä¼ å…¥ LangChain æˆ–å…¶ä»– LLM å®ä¾‹
    vectorStore: IVectorStore;
    trajectoryStore: ITrajectoryStore;
    analyticsStore?: IAnalyticsStore;
  }) {
    super();
    // åˆå§‹åŒ–å­ç»„ä»¶
    this.generator = new Generator(config.llm, config.vectorStore);
    this.reflector = new Reflector(config.llm);
    this.curator = new Curator(config.llm, config.vectorStore);
  }

  /**
   * æ ¸å¿ƒè¿è¡Œæ–¹æ³•
   */
  async run(task: string): Promise<string> {
    // 1. æ£€ç´¢ç›¸å…³è§„åˆ™ (Playbook Retrieval)
    const context = await this.generator.retrieveContext(task);
    
    // 2. æ‰§è¡Œä»»åŠ¡ (Generation)
    const { result, trajectory } = await this.generator.execute(task, context);
    
    // 3. ä¿å­˜åŸå§‹è½¨è¿¹ (Persistence)
    await this.trajectoryStore.saveTrajectory(trajectory);

    // 4. è§¦å‘å¼‚æ­¥è¿›åŒ– (Fire and Forget)
    this.evolve(trajectory).catch(err => this.emit('error', err));

    return result;
  }

  /**
   * åå°è¿›åŒ–é€»è¾‘ (The Evolution Loop)
   */
  private async evolve(traj: Trajectory) {
    this.emit('status', 'reflecting');
    
    // 1. åæ€ (Reflection)
    const insights = await this.reflector.analyze(traj);
    
    // 2. ç­–å±• (Curation)
    this.emit('status', 'curating');
    const deltas = await this.curator.processInsights(insights, traj.task_id);
    
    // 3. åº”ç”¨æ›´æ–° (Update)
    if (deltas.length > 0) {
      await this.curator.applyDeltas(deltas);
      
      // è®°å½•æ—¥å¿—åˆ° DuckDB æ¥å£
      if (this.analyticsStore) {
         await this.analyticsStore.logEvent({ type: 'PLAYBOOK_UPDATE', payload: deltas, timestamp: Date.now() });
      }
      
      this.emit('evolved', deltas);
    }
  }
}
```

-----

## å…­ã€ Host App (ä¸šåŠ¡å·¥ç¨‹) æ¥å…¥ç¤ºä¾‹

è¿™æ˜¯åœ¨æ‚¨çš„ Node.js æœåŠ¡å™¨ä»£ç ä¸­å¦‚ä½•ä½¿ç”¨ä¸Šé¢å†™å¥½çš„ SDKã€‚

### 1\. å®ç°é€‚é…å™¨ (`src/adapters/`)

**ChromaAdapter.ts:**

```typescript
import { ChromaClient } from 'chromadb';
import { IVectorStore, Rule } from 'ace-engine-core';

export class ChromaAdapter implements IVectorStore {
  private collection: any;
  constructor(private client: ChromaClient) {}
  
  async init() {
    this.collection = await this.client.getOrCreateCollection({ name: "ace_rules" });
  }

  async search(query: string, limit: number): Promise<Rule[]> {
    const results = await this.collection.query({ queryTexts: [query], nResults: limit });
    // è½¬æ¢ Chroma æ ¼å¼åˆ° SDK Rule æ ¼å¼...
    return mapToRules(results);
  }
  
  // ... å®ç° add, update, delete
}
```

**DuckDBAdapter.ts:**

```typescript
import { Database } from 'duckdb-async';
import { IAnalyticsStore } from 'ace-engine-core';

export class DuckDBAdapter implements IAnalyticsStore {
  constructor(private db: Database) {}
  
  async logEvent(event: any) {
    await this.db.run(
      `INSERT INTO ace_logs (type, payload, timestamp) VALUES (?, ?, ?)`, 
      [event.type, JSON.stringify(event.payload), event.timestamp]
    );
  }
}
```

### 2\. ä¸šåŠ¡ä»£ç è°ƒç”¨

```typescript
// app.ts
import { AceAgent } from 'ace-engine-core';
import { ChromaAdapter } from './adapters/ChromaAdapter';
import { RxDBAdapter } from './adapters/RxDBAdapter';
import { DuckDBAdapter } from './adapters/DuckDBAdapter';
import { ChatOpenAI } from '@langchain/openai';

async function main() {
  // 1. å‡†å¤‡åŸºç¡€è®¾æ–½
  const chroma = new ChromaAdapter(...);
  const rxdb = new RxDBAdapter(...);
  const duckdb = new DuckDBAdapter(...);
  const llm = new ChatOpenAI({ modelName: 'gpt-4' });

  // 2. åˆå§‹åŒ– SDK
  const agent = new AceAgent({
    llm,
    vectorStore: chroma,
    trajectoryStore: rxdb,
    analyticsStore: duckdb
  });

  // 3. ç›‘å¬è¿›åŒ–äº‹ä»¶
  agent.on('evolved', (deltas) => {
    console.log('ğŸš€ Agent è¿›åŒ–äº†! æ›´æ–°äº†è§„åˆ™:', deltas);
  });

  // 4. æ‰§è¡Œä»»åŠ¡
  const response = await agent.run("å¸®æˆ‘å†™ä¸€ä¸ª Python è„šæœ¬æŸ¥è¯¢å¤©æ°”");
  console.log("Agent å›å¤:", response);
  
  // æ­¤æ—¶ï¼Œåå°æ­£åœ¨è¿›è¡Œ Reflection å’Œ Curationï¼Œå‡ ç§’åä¼šè§¦å‘ 'evolved' äº‹ä»¶
}
```

-----

## ä¸ƒã€ ç›®å½•ç»“æ„è§„åˆ’ (SDK ä»“åº“)

```text
ace-engine-core/
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts             # å¯¼å‡º AceAgent, Interfaces
â”‚   â”œâ”€â”€ agent.ts             # AceAgent ä¸»ç±»
â”‚   â”œâ”€â”€ types.ts             # æ•°æ®ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â””â”€â”€ store.ts         # å­˜å‚¨é€‚é…å™¨æ¥å£å®šä¹‰
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ generator.ts     # ç”Ÿæˆå™¨é€»è¾‘
â”‚   â”‚   â”œâ”€â”€ reflector.ts     # åæ€å™¨é€»è¾‘
â”‚   â”‚   â””â”€â”€ curator.ts       # ç­–å±•äººé€»è¾‘
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ prompt-templates.ts  # å†…ç½® Prompt æ¨¡æ¿
â”‚       â””â”€â”€ token-counter.ts
```

-----

## å…«ã€ å¼€å‘è·¯çº¿å›¾å»ºè®®

1.  **Phase 1: éª¨æ¶æ­å»º**

      * å®šä¹‰ `types.ts` å’Œ `interfaces/store.ts`ã€‚
      * ç¼–å†™ `AceAgent` çš„ç©ºå£³ç±»ã€‚
      * å®ç°ä¸€ä¸ªç®€å•çš„ `InMemoryVectorStore` (å†…å­˜æ•°ç»„) ç”¨äºå•å…ƒæµ‹è¯•ã€‚

2.  **Phase 2: æ ¸å¿ƒç»„ä»¶å®ç°**

      * å®ç° `Generator`ï¼šè·‘é€š Prompt + Context -\> LLM çš„æµç¨‹ã€‚
      * å®ç° `Reflector`ï¼šç¼–å†™ prompt templateï¼Œæå– insightsã€‚

3.  **Phase 3: Curator ä¸æŒä¹…åŒ–**

      * å®ç° `Curator` çš„å»é‡é€»è¾‘ï¼ˆæ¯”è¾ƒ embedding ç›¸ä¼¼åº¦ï¼‰ã€‚
      * åœ¨å®¿ä¸»å·¥ç¨‹ä¸­å®ç° `ChromaAdapter` å¹¶è”è°ƒã€‚

4.  **Phase 4: å¼‚æ­¥ä¸äº‹ä»¶**

      * å®Œå–„ `EventEmitter`ã€‚
      * å¯¹æ¥ `DuckDB` å’Œ `RxDB` é€‚é…å™¨ã€‚

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆä¿è¯äº†æ‚¨çš„ä»£ç åº“æ•´æ´ã€å¯ç»´æŠ¤ï¼Œå¹¶ä¸”å……åˆ†åˆ©ç”¨äº† Node.js ç”Ÿæ€çš„ä¼˜åŠ¿ã€‚æ‚¨å¯ä»¥ç›´æ¥æŒ‰ç…§æ­¤ç»“æ„å¼€å§‹åˆå§‹åŒ– npm é¡¹ç›®ã€‚
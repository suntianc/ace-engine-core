# ACE Engine Core 项目规范审查报告

## 审查概述

本报告基于 `ACE终极详细设计.md` 文档，对 `ace-engine-core` npm SDK 项目进行深度审查。审查角度：作为 npm SDK 项目，用于其他项目引用使用。

**审查日期**: 2024年
**审查范围**: 核心架构、层级实现、存储系统、总线通信、API设计

---

## 一、总线系统 (Bus System) 审查

### ✅ 符合规范的部分

1. **总线管理器实现**: `BusManager` 类正确实现了北向和南向两个独立的 EventEmitter 实例
2. **Zod Schema 校验**: 正确使用 Zod 进行运行时数据包格式校验
3. **中间件模式**: 实现了中间件机制，支持安全审计和日志记录
4. **安全覆盖层**: `SecurityOverlay` 实现了禁止危险命令、检测死循环、数据脱敏等功能

### ❌ 不符合规范的问题

#### 问题 1.1: 数据包持久化日志位置不当
**规范要求** (设计文档 3.2.2):
> 在 `publishSouthbound` 中，应该先执行中间件，然后持久化日志到 DuckDB，最后才分发事件。

**实际实现** (`ace_engine.ts:161-172`):
```typescript
// 日志记录在中间件中执行，而不是在 BusManager 内部
this.bus.use(BusDirection.SOUTHBOUND, async (packet, next) => {
    await this.storage.duckdb.logDirective(packet);
    await next();
});
```

**问题描述**:
- 日志记录应该作为 BusManager 的内部逻辑，而不是外部中间件
- 设计文档明确要求：`await this.logger.logSouthbound(packet);` 应该在中间件执行后、事件分发前执行
- 当前实现将日志记录委托给外部中间件，违反了封装原则

**影响**: 
- 如果用户未注册日志中间件，指令历史将不会被记录
- 作为 SDK，应该保证核心功能（日志记录）的可靠性

---

#### 问题 1.2: 安全覆盖层未完全集成到总线流程
**规范要求** (设计文档 3.2.2):
> 安全覆盖层应该在 BusManager 内部作为默认中间件注册，并在中间件链中执行。

**实际实现** (`bus.ts:111-113`):
```typescript
// 安全覆盖层已注册，但实现方式与设计文档不完全一致
this.use(BusDirection.SOUTHBOUND, SecurityOverlay.monitorSouthbound);
this.use(BusDirection.NORTHBOUND, SecurityOverlay.monitorNorthbound);
```

**问题描述**:
- 实现基本符合要求，但设计文档中提到的"硬编码规则引擎位于 BusManager 内部"的表述暗示应该更紧密集成
- 当前实现是正确的，但可以进一步优化为内部方法而非静态方法

**影响**: 轻微，当前实现可用

---

## 二、存储层 (Storage Layer) 审查

### ✅ 符合规范的部分

1. **复合存储模式**: 正确实现了 SQLite + DuckDB 的复合存储架构
2. **SQLite 表结构**: `layer_state`, `capabilities`, `active_goals`, `kv_store` 表结构符合设计文档
3. **DuckDB 表结构**: `telemetry_log`, `directives_log`, `metrics` 表结构符合设计文档附录
4. **WAL 模式**: SQLite 正确开启了 WAL 模式以支持高并发

### ❌ 不符合规范的问题

#### 问题 2.1: SQLite capabilities 表字段类型不一致
**规范要求** (设计文档 4.3.2):
```sql
CREATE TABLE capabilities (
    id INTEGER PRIMARY KEY,
    tool_name TEXT NOT NULL UNIQUE,
    description TEXT,
    input_schema JSON,  -- JSON Schema 格式的参数定义
    is_active BOOLEAN DEFAULT 1,
    risk_level INTEGER  -- 1-5，用于安全控制
);
```

**实际实现** (`sqlite.ts:27-38`):
```typescript
CREATE TABLE IF NOT EXISTS capabilities (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    tool_name TEXT NOT NULL UNIQUE,
    description TEXT,
    input_schema TEXT,  // ❌ 应该是 JSON，但 SQLite 不支持 JSON 类型，存储为 TEXT 是合理的
    is_active BOOLEAN DEFAULT 1,
    risk_level INTEGER DEFAULT 5,  // ❌ 设计文档要求 1-5，但默认值是 5（最高风险）
    permissions TEXT,  // ✅ 额外字段，符合扩展性要求
    layer_id TEXT      // ✅ 额外字段，符合扩展性要求
)
```

**问题描述**:
- `risk_level` 默认值设置为 5（最高风险），不符合安全最佳实践
- 设计文档要求风险等级为 1-5，但未明确默认值应该是多少
- 作为 SDK，默认值应该更保守（建议默认值为 3 或更低）

**影响**: 中等，可能导致新注册的工具默认风险等级过高

---

#### 问题 2.2: DuckDB 初始化时删除表结构
**实际实现** (`duckdb.ts:18-50`):
```typescript
// 每次初始化都删除表
await this.db.run(`DROP TABLE IF EXISTS telemetry_log;`);
await this.db.run(`DROP TABLE IF EXISTS directives_log;`);
await this.db.run(`DROP TABLE IF EXISTS metrics;`);
```

**问题描述**:
- 作为 SDK，初始化时不应该删除历史数据
- 应该使用 `CREATE TABLE IF NOT EXISTS` 而不是 `DROP TABLE IF EXISTS`
- 这会导致每次重启引擎时丢失所有历史遥测数据

**影响**: **严重** - 作为 SDK，这会导致用户数据丢失

---

#### 问题 2.3: DuckDB 数据脱敏逻辑重复
**规范要求** (设计文档 3.2.2):
> 强制所有北向敏感数据在写入 DuckDB 日志前进行脱敏

**实际实现**:
- `bus.ts:80-97`: SecurityOverlay 中有脱敏逻辑
- `duckdb.ts:84-103`: DuckDBStorage 中也有脱敏逻辑（但未使用）

**问题描述**:
- 脱敏逻辑重复，且 DuckDB 中的 `redact` 方法未被调用
- 应该在 `logTelemetry` 方法中调用脱敏逻辑

**影响**: 中等，可能导致敏感数据泄露到日志中

---

## 三、缓存层 (Cache Layer) 审查

### ✅ 符合规范的部分

1. **双模自适应**: 正确实现了 Redis 和内存 LRU 两种模式
2. **上下文窗口管理**: 实现了 `pushToContextWindow` 和自动淘汰机制
3. **层级锁机制**: 实现了 `acquireLayerLock`, `releaseLayerLock`, `isLayerLocked`

### ❌ 不符合规范的问题

#### 问题 3.1: 上下文窗口键名不符合设计文档
**规范要求** (设计文档 3.4.2):
> `context_window:{sessionId}` (List): 存储最近 N 轮对话或思维链的 Token 序列

**实际实现** (`memory.ts:47-58`):
```typescript
const key = `context:${sessionId}`;  // ❌ 应该是 context_window:{sessionId}
```

**问题描述**:
- 键名应该是 `context_window:{sessionId}` 而不是 `context:{sessionId}`
- 虽然功能上等价，但不符合设计文档的命名规范

**影响**: 轻微，但作为 SDK 应该严格遵循设计文档

---

#### 问题 3.2: 上下文窗口最大长度硬编码
**实际实现** (`memory.ts:11`):
```typescript
private static MAX_CONTEXT_WINDOW = 10; // Example limit
```

**问题描述**:
- 最大上下文窗口长度硬编码为 10，且注释为 "Example limit"
- 作为 SDK，应该允许用户配置此参数
- 设计文档未明确指定默认值，但应该可配置

**影响**: 中等，限制了 SDK 的灵活性

---

#### 问题 3.3: 层级锁在内存模式下的实现不完整
**实际实现** (`memory.ts:69-95`):
```typescript
// 内存模式下，锁的过期检查逻辑存在问题
if (existing) {
    const lockTimestamp = parseInt(existing);
    const now = Date.now();
    if (now - lockTimestamp < timeout * 1000) {
        return false; // Lock still valid
    }
    this.lru.delete(key);
}
```

**问题描述**:
- LRU Cache 本身支持 TTL，但代码手动检查过期时间
- 如果 LRU Cache 的 TTL 机制正常工作，手动检查是冗余的
- 应该依赖 LRU Cache 的 TTL 机制，而不是手动检查

**影响**: 轻微，功能可用但实现不够优雅

---

## 四、层级实现 (Layer Implementation) 审查

### ✅ 符合规范的部分

1. **六层架构**: 正确实现了所有六个层级
2. **双向通信**: 各层级正确实现了 `handleSouthbound` 和 `handleNorthbound`
3. **状态管理**: CognitiveControlLayer 正确实现了 FocusState 状态机
4. **挫折感机制**: 正确实现了失败计数和 FRUSTRATION_SIGNAL 发送

### ❌ 不符合规范的问题

#### 问题 4.1: 愿景层宪法加载路径不符合 SDK 规范
**规范要求** (设计文档 4.1.2):
> 宪法加载器 (Constitution Loader): 在启动时从 constitution.md 或环境变量中加载核心指令

**实际实现** (`aspirational.ts:16-55`):
```typescript
const possiblePaths = [
    path.join(process.cwd(), 'constitution.md'),  // ❌ 作为 SDK，不应该依赖 process.cwd()
    path.join(__dirname, '../../config/constitution.md'),
    // ...
];
```

**问题描述**:
- 作为 npm SDK，不应该依赖 `process.cwd()`，因为用户项目的工作目录可能不同
- 应该优先从环境变量 `CONSTITUTION_PATH` 加载，如果未设置，应该提供明确的配置选项
- 当前实现会尝试多个路径，但作为 SDK，应该更明确地要求用户配置

**影响**: 中等，可能导致在用户项目中找不到宪法文件

---

#### 问题 4.2: 代理模型层风险阈值硬编码
**规范要求** (设计文档 4.3.3):
> 如果 risk_level 超过了当前的安全阈值，代理模型层会向北向总线发送 CAPABILITY_ERROR

**实际实现** (`agent_model.ts:8-14`):
```typescript
private static DEFAULT_RISK_THRESHOLD = 8; // ❌ 设计文档要求 1-5，但这里使用 1-10 的尺度
private riskThreshold: number;

constructor(bus: BusManager, storage: AceStorages, llm: BaseLLM, riskThreshold?: number) {
    // ...
    this.riskThreshold = riskThreshold ?? AgentModelLayer.DEFAULT_RISK_THRESHOLD;
}
```

**问题描述**:
- 设计文档明确要求风险等级为 1-5，但代码中使用 1-10 的尺度
- 默认阈值 8 在 1-10 尺度下是合理的，但与设计文档的 1-5 尺度不一致
- 应该统一为 1-5 尺度，或明确文档说明使用 1-10 尺度

**影响**: 中等，可能导致风险判断不一致

---

#### 问题 4.3: 执行功能层计划存储键名不符合设计文档
**规范要求** (设计文档 4.4.2):
> 将生成的计划序列化存储到 Redis 的 `active_plan:{id}` 中

**实际实现** (`executive_function.ts:39`):
```typescript
await this.storage.memory.set(`active_plan:${packet.id}`, JSON.stringify(planWithStates));
```

**问题描述**:
- 实现符合设计文档要求 ✅
- 但设计文档提到存储到 "Redis"，实际实现使用 `storage.memory`（可能是 Redis 或内存）
- 这是合理的抽象，但文档说明可以更清晰

**影响**: 无，实现正确

---

#### 问题 4.4: 认知控制层状态转换日志未正确处理异步
**实际实现** (`cognitive_control.ts:103-112`):
```typescript
this.storage.duckdb.run(`
    INSERT INTO metrics(ts, layer, metric_name, value) VALUES(?, ?, ?, ?)
`, [
    new Date(),
    this.id,
    'focus_state_transition',
    1
]).catch(err => {
    console.error('[CognitiveControl] Failed to log state transition:', err);
});
```

**问题描述**:
- `duckdb.run` 返回 Promise，但未使用 `await`
- 虽然使用了 `.catch()` 处理错误，但作为 SDK，应该确保日志记录的可靠性
- 应该使用 `await` 或至少确保错误被正确处理

**影响**: 轻微，可能导致日志记录失败但程序继续运行

---

#### 问题 4.5: 任务执行层安全沙箱实现过于简单
**规范要求** (设计文档 4.6.3):
> 为了防止 LLM 生成恶意代码，该层建议在 Node.js 的 vm 模块或独立的 Docker 容器中执行非预设的代码。但在基础 SDK 中，我们将重点放在预定义工具的安全调用上，对每个调用进行参数校验。

**实际实现** (`task_prosecution.ts:62-73`):
```typescript
private sandboxCheck(toolName: string, args: any): boolean {
    const BLACKLIST = ['eval', 'exec', 'system'];
    if (BLACKLIST.includes(toolName)) return false;
    
    const argsStr = JSON.stringify(args);
    if (argsStr.includes('rm -rf') || argsStr.includes('sudo')) return false;
    
    return true;
}
```

**问题描述**:
- 实现过于简单，仅检查工具名黑名单和参数中的字符串
- 设计文档提到"对每个调用进行参数校验"，应该使用 Zod schema 进行更严格的校验
- 当前实现中，`tool.schema.parse(args)` 在 `executeTool` 中执行，但应该在 `sandboxCheck` 中执行

**影响**: 中等，安全防护不够严格

---

## 五、API 设计审查

### ✅ 符合规范的部分

1. **初始化配置**: `AceEngineConfig` 接口符合设计文档要求
2. **工具注册**: `registerTool` 方法符合设计文档要求
3. **中间件 API**: `bus.use()` 方法符合设计文档要求

### ❌ 不符合规范的问题

#### 问题 5.1: 配置接口缺少可选性说明
**规范要求** (设计文档 5.1):
> 提供完整的初始化配置示例，包括所有必需和可选参数

**实际实现** (`types/index.ts:95-101`):
```typescript
export interface AceEngineConfig {
    agentId: string;
    storage: AceStorageConfig;
    cache: AceCacheConfig;
    memory: AceMemoryConfig;
    llm: AceLLMConfig;
}
```

**问题描述**:
- 所有字段都是必需的，但作为 SDK，某些字段应该有合理的默认值
- 例如 `cache.redisUrl` 应该是可选的（当 `cache.type === 'memory'` 时）
- 应该使用 TypeScript 的联合类型或条件类型来更精确地定义配置

**影响**: 中等，增加了 SDK 的使用复杂度

---

#### 问题 5.2: 缺少公开的 API 方法获取层级状态
**规范要求** (设计文档 5.2):
> SDK 应该提供查询各层级状态的 API

**实际实现**:
- `CognitiveControlLayer` 有 `getFocusState()` 方法，但未暴露在 `AceEngine` 类中
- 其他层级的状态查询方法未实现

**问题描述**:
- 作为 SDK，应该提供统一的 API 来查询各层级状态
- 例如：`engine.getLayerState(layerId)` 或 `engine.getCognitiveControlState()`

**影响**: 中等，限制了 SDK 的可观测性

---

#### 问题 5.3: 缺少错误处理和错误类型定义
**规范要求** (设计文档 6.2):
> SDK 应该提供统一的错误处理机制

**实际实现**:
- 各层级使用 `console.error` 和 `console.warn` 进行错误处理
- 未定义统一的错误类型
- 未提供错误处理回调或事件

**问题描述**:
- 作为 SDK，应该定义统一的错误类型（如 `AceError`, `SecurityError`, `CapabilityError` 等）
- 应该提供错误事件或回调机制，让用户能够处理错误
- 当前实现中，错误主要通过日志输出，用户难以程序化处理

**影响**: 中等，降低了 SDK 的可用性

---

## 六、认知调度器 (Cognitive Scheduler) 审查

### ✅ 符合规范的部分

1. **心跳机制**: 正确实现了每秒触发的心跳
2. **反思周期**: 正确实现了每 5 分钟触发的反思周期

### ❌ 不符合规范的问题

#### 问题 6.1: 心跳和反思周期不可配置
**规范要求** (设计文档 6.1):
> 心跳间隔和反思周期应该是可配置的

**实际实现** (`scheduler.ts:13-16`):
```typescript
constructor(bus: BusManager, intervalMs: number = 1000) {
    this.bus = bus;
    this.intervalMs = intervalMs;  // ✅ 心跳间隔可配置
    this.reflectionIntervalMs = 5 * 60 * 1000;  // ❌ 反思周期硬编码
}
```

**问题描述**:
- 心跳间隔可通过构造函数参数配置 ✅
- 但反思周期硬编码为 5 分钟，应该也允许配置
- 作为 SDK，应该允许用户根据需求调整这些参数

**影响**: 轻微，限制了灵活性

---

## 七、ChromaDB 集成审查

### ✅ 符合规范的部分

1. **集合划分**: 正确实现了 `ace_episodic`, `ace_knowledge`, `ace_procedures` 三个集合
2. **集合命名**: 使用 `collectionPrefix` 符合设计文档要求

### ❌ 不符合规范的问题

#### 问题 7.1: 集合命名与设计文档不完全一致
**规范要求** (设计文档 3.5):
> 集合划分: `ace_episodic`, `ace_knowledge`, `ace_procedures`

**实际实现** (`chroma.ts:17-25`):
```typescript
this.episodicCollection = await this.client.getOrCreateCollection({
    name: `${this.prefix}_episodic`,  // ✅ 符合
});
this.knowledgeCollection = await this.client.getOrCreateCollection({
    name: `${this.prefix}_knowledge`,  // ✅ 符合
});
this.proceduralCollection = await this.client.getOrCreateCollection({
    name: `${this.prefix}_procedures`,  // ❌ 设计文档是 ace_procedures，但这里是 procedures
});
```

**问题描述**:
- 设计文档明确要求集合名为 `ace_procedures`，但代码中使用 `procedures`
- 虽然通过 `prefix` 可以统一前缀，但后缀不一致

**影响**: 轻微，但不符合设计文档

---

## 八、类型定义审查

### ✅ 符合规范的部分

1. **数据包接口**: `SouthboundPacket` 和 `NorthboundPacket` 符合设计文档
2. **层级枚举**: `AceLayerID` 枚举正确
3. **类型枚举**: `SouthboundType` 和 `NorthboundType` 正确

### ❌ 不符合规范的问题

#### 问题 8.1: 缺少 CRITICAL_FAILURE 类型
**规范要求** (设计文档 4.1.3):
> 愿景层应该监听北向总线的 EPIPHANY 或 CRITICAL_FAILURE 事件

**实际实现** (`types/index.ts:29-37`):
```typescript
export enum NorthboundType {
    OBSERVATION = 'OBSERVATION',
    RESULT = 'RESULT',
    STATUS = 'STATUS',
    FAILURE = 'FAILURE',  // ❌ 缺少 CRITICAL_FAILURE
    EPIPHANY = 'EPIPHANY',
    FRUSTRATION_SIGNAL = 'FRUSTRATION_SIGNAL',
    CAPABILITY_ERROR = 'CAPABILITY_ERROR',
}
```

**问题描述**:
- 设计文档明确提到 `CRITICAL_FAILURE` 类型
- 当前实现使用 `FAILURE` 类型配合 `data.critical` 标志来表示严重失败
- 虽然功能上等价，但不符合设计文档的明确要求

**影响**: 轻微，但不符合设计文档

---

#### 问题 8.2: AceTool 接口中 schema 类型定义不精确
**规范要求** (设计文档 4.6.2):
> `schema: object; // Zod schema`

**实际实现** (`types/index.ts:105-110`):
```typescript
export interface AceTool {
    name: string;
    description: string;
    execute: (params: any) => Promise<any>;
    schema: z.ZodType<any>; // ✅ 使用 ZodType 更精确
}
```

**问题描述**:
- 实现比设计文档更精确 ✅
- 但设计文档提到 "Zod schema"，实际使用 `z.ZodType<any>` 是正确的

**影响**: 无，实现更优

---

## 九、SDK 作为 npm 包的审查

### ❌ 不符合规范的问题

#### 问题 9.1: 缺少 TypeScript 声明文件导出检查
**实际实现** (`index.ts:1-18`):
```typescript
export { AceEngine } from './ace_engine';
export * from './types';
export { BusManager } from './core/bus';
// ...
```

**问题描述**:
- 虽然 `tsconfig.json` 中设置了 `declaration: true`，但需要确认所有导出的类型都有对应的声明文件
- 作为 SDK，应该确保所有公共 API 都有完整的类型定义

**影响**: 需要进一步检查编译后的 `.d.ts` 文件

---

#### 问题 9.2: 依赖版本未锁定
**实际实现** (`package.json:26-34`):
```json
"dependencies": {
    "better-sqlite3": "^11.7.0",  // ❌ 使用 ^ 允许小版本更新
    "chromadb": "^1.9.2",
    // ...
}
```

**问题描述**:
- 作为 SDK，使用 `^` 允许依赖的小版本更新可能导致兼容性问题
- 应该考虑使用更严格的版本锁定，或至少提供 `package-lock.json`

**影响**: 中等，可能导致不同环境下的行为不一致

**注意**: 项目中有 `package-lock.json`，这可以缓解问题

---

#### 问题 9.3: 缺少使用示例和文档
**规范要求** (设计文档 5.1):
> 提供完整的 API 使用示例

**实际实现**:
- 需要检查 `examples/` 目录和 `README.md`

**问题描述**:
- 作为 SDK，应该提供完整的使用示例
- 应该包括：基本初始化、工具注册、错误处理、配置选项等

**影响**: 需要进一步检查文档完整性

---

## 十、总结

### 严重问题 (必须修复)

1. **问题 2.2**: DuckDB 初始化时删除表结构，导致数据丢失
2. **问题 2.3**: DuckDB 数据脱敏逻辑未在日志记录时执行

### 中等问题 (建议修复)

1. **问题 1.1**: 数据包持久化日志应该作为 BusManager 内部逻辑
2. **问题 2.1**: SQLite capabilities 表 risk_level 默认值不合理
3. **问题 4.1**: 愿景层宪法加载路径不符合 SDK 规范
4. **问题 4.2**: 代理模型层风险阈值尺度不一致
5. **问题 4.5**: 任务执行层安全沙箱实现过于简单
6. **问题 5.1**: 配置接口缺少可选性说明
7. **问题 5.2**: 缺少公开的 API 方法获取层级状态
8. **问题 5.3**: 缺少错误处理和错误类型定义

### 轻微问题 (可选修复)

1. **问题 3.1**: 上下文窗口键名不符合设计文档
2. **问题 3.2**: 上下文窗口最大长度硬编码
3. **问题 4.4**: 认知控制层状态转换日志未正确处理异步
4. **问题 6.1**: 反思周期不可配置
5. **问题 7.1**: ChromaDB 集合命名不完全一致
6. **问题 8.1**: 缺少 CRITICAL_FAILURE 类型

---

## 审查结论

总体而言，`ace-engine-core` 项目**基本符合**设计文档的要求，核心架构和主要功能都已实现。但作为 npm SDK，在以下方面需要改进：

1. **数据持久化**: 确保历史数据不会丢失
2. **配置灵活性**: 提供更多可配置选项
3. **错误处理**: 提供统一的错误处理机制
4. **API 完整性**: 提供更完整的公共 API
5. **文档完整性**: 确保所有功能都有使用示例

建议优先修复**严重问题**，然后逐步改进**中等问题**，最后优化**轻微问题**。

